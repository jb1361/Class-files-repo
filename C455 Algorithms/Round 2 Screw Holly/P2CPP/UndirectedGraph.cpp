//#include <Wrapper.h>
//#include <UndirectedGraphAdjMatrix.h>

template <class T>
	class UndirectedGraph {		
	//private:
		//UndirectedGraphAdjMatrix<T> g1;
		////UndirectedGraphAdjList<T> g2 = new UndirectedGraphAdjList<T>();
		//template <class T>
		//class Edge {
		//private:
		//	Text v1;
		//	Text v2;

		//public:
		//	Edge() {
		//		v1 = 0;
		//		v2 = 0;
		//	}

		//	Edge(T v1, T v2) {
		//		this.Getv1 = v1;
		//		this.Getv2 = v2;
		//	}

		//	void clear()
		//	{
		//		v1 = 0;
		//		v2 = 0;
		//	}
		//	template <class T>
		//	T Getv1() {
		//		return v1;
		//	}
		//	template <class T>
		//	T Getv2() {
		//		return v2;
		//	}
		//	void ToString()
		//	{
		//		wcout << "{" << v1 << "," << v2 << "}";
		//	}
		//};

	public:
		UndirectedGraph::UndirectedGraph()
		{
			//WTF IS GOING ONNNNN????
			int lol = 0;
			//g1 = new UndirectedGraphAdjMatrix<T>();
		}
		UndirectedGraph::~UndirectedGraph()
		{
			//g1.~UndirectedGraphAdjMatrix;
		}
		//void UndirectedGraph<T>::SetVertices(Sequence1<T> n)
		//{
		//	g1.SetVertices(n);
		//	//g2.SetVertices(n);
		//}
		//void UndirectedGraph<T>::AddEdge(T x, T y)
		//{
		//	g1.AddEdge(x, y);

		//}
		///*void UndirectedGraph<T>::RemoveEdge(T v1, T v2)
		//{
		//	g1.RemoveEdge(v1, v2);
		//}
		//template <class T>
		//UndirectedGraph<T>::RemoveAnyIncidentEdge(T v1)
		//{
		//	return g1.RemoveAnyIncidentEdge(v1);
		//}*/
		///*void UndirectedGraph<T>::clear()
		//{
		//	g1.clear();
		//}*/

		//Integer UndirectedGraph<T>::NumberOfVertices()
		//{
		//	return g1.NumberOfVertices();
		//}

		//Integer UndirectedGraph<T>::NumberOfEdges()
		//{
		//	return g1.NumberOfEdges();
		//}
		//Integer UndirectedGraph<T>::Degree(T v1)
		//{
		//	return g1.Degree(v1);
		//}
		//Boolean UndirectedGraph<T>::IsEdge(T v1, T v2)
		//{
		//	return g1.IsEdge(v1, v2);
		//}
		//Edge<T> UndirectedGraph<T>::RemoveAnyEdge()
		//{
		//	Edge<T> e = g1.RemoveAnyEdge();
		//	//Edge<T> ee = new Edge<T>(e.v1, e.v2);
		//	return e;
		//}

		// Operation #1
		//void ListRecursiveSearch()
		//{

		//}
		//// Operation #2
		//void ListIterativeSearch()
		//{

		//}
		//// Operation #3
		//void MatrixRecursiveSearch()
		//{

		//}
		//// Operation #4
		//void MatrixIterativeSearch()
		//{

		//}
		//Text UndirectedGraph<T>::ToString()
		//{
		//	return g1.ToString();
		//} // ToString     
};

